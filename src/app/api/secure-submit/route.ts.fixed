// Route handler for form submissions with CSRF protection
import { prisma } from "@/lib/prisma";
import { NextRequest, NextResponse } from "next/server";
import {
  formSubmissionSchema,
  sanitizeEmail,
  sanitizeFormData,
  checkRateLimit,
} from "@/lib/form-validation";
import { verifyCSRFToken, consumeCSRFToken } from "@/lib/csrf";

// Sprawdzenie środowiska uruchomieniowego i konfiguracji bazy danych
const isDevelopment = process.env.NODE_ENV === 'development';
console.log(`API running in ${process.env.NODE_ENV} mode`);
if (isDevelopment) {
  console.log("Database URL (masked):", process.env.DATABASE_URL?.substring(0, 15) + '...');
}

// Set security headers for API responses
const securityHeaders = {
  "Content-Security-Policy": "default-src 'self'",
  "X-Content-Type-Options": "nosniff",
  "X-Frame-Options": "DENY",
  "Referrer-Policy": "strict-origin-when-cross-origin",
  "Permissions-Policy": "camera=(), microphone=(), geolocation=()",
};

export async function POST(request: NextRequest) {
  try {
    // Get IP for rate limiting
    const ip = request.headers.get("x-forwarded-for") || "anonymous";

    // Apply rate limiting
    if (!checkRateLimit(ip, 5, 60000)) {
      return NextResponse.json(
        { error: "Zbyt wiele żądań. Spróbuj ponownie za kilka minut." },
        {
          status: 429,
          headers: {
            ...securityHeaders,
            "Retry-After": "60",
          },
        }
      );
    }
    
    // Check for CSRF token in headers
    const csrfToken = request.headers.get("X-CSRF-Token");
    if (!csrfToken) {
      return NextResponse.json(
        {
          error:
            "Brak tokenu bezpieczeństwa. Odśwież stronę i spróbuj ponownie.",
        },
        { status: 403, headers: securityHeaders }
      );
    }

    // Verify the token exists and is valid
    if (!verifyCSRFToken(csrfToken)) {
      return NextResponse.json(
        {
          error:
            "Nieprawidłowy token bezpieczeństwa. Odśwież stronę i spróbuj ponownie.",
        },
        { status: 403, headers: securityHeaders }
      );
    }

    // Consume the token so it can't be reused (One-time use tokens)
    consumeCSRFToken(csrfToken); 
    
    // Parse the request body
    const body = await request.json();
    console.log("Received body:", JSON.stringify(body));

    // Sanitize the data to prevent injection attacks
    const sanitizedBody = sanitizeFormData(body);
    console.log("Sanitized body:", JSON.stringify(sanitizedBody));

    // Check honeypot field - if it's not empty, it's likely a bot
    if (sanitizedBody.notHuman && sanitizedBody.notHuman.length > 0) {
      // Don't reveal that we detected a bot - just return a success message
      console.warn("Bot detected via honeypot field - IP:", ip);
      return NextResponse.json(
        { success: true, message: "Form submitted successfully" },
        { status: 200, headers: securityHeaders }
      );
    }
    
    const {
      contactEmail,
      zgodaPrzetwarzanie,
      zgodaKontakt,
      // Reszta danych formularza (obecnie nieużywana)
      ..._unusedFormData
    } = sanitizedBody;

    console.log("Email from request:", contactEmail);

    // Basic validation
    if (!contactEmail || typeof contactEmail !== "string") {
      console.error("Email validation failed:", {
        contactEmail,
        body: sanitizedBody,
      });
      return NextResponse.json(
        { error: "Email jest wymagany" },
        { status: 400, headers: securityHeaders }
      );
    }

    if (!zgodaPrzetwarzanie || !zgodaKontakt) {
      return NextResponse.json(
        { error: "Wymagane są obie zgody" },
        { status: 400, headers: securityHeaders }
      );
    }

    // Proper email sanitization and verification
    const cleanEmail = sanitizeEmail(contactEmail);
    console.log("Sanitized email:", cleanEmail);

    if (!cleanEmail || cleanEmail.length < 5 || !cleanEmail.includes("@")) {
      console.error("Email format validation failed:", { cleanEmail });
      return NextResponse.json(
        { error: "Nieprawidłowy format adresu email" },
        { status: 400, headers: securityHeaders }
      );
    }
    
    // Validate with Zod schema
    try {
      formSubmissionSchema.parse({
        contactEmail: cleanEmail,
        zgodaPrzetwarzanie,
        zgodaKontakt,
        submissionDate:
          sanitizedBody.submissionDate || new Date().toISOString(),
      });
    } catch (validationError) {
      console.error("Validation error:", validationError);
      return NextResponse.json(
        { error: "Nieprawidłowe dane formularza" },
        { status: 400, headers: securityHeaders }
      );
    }
    
    try {
      // Try to save the email subscription with proper schema
      let subscription;
      try {
        console.log("Connecting to database...");
        
        // Próba połączenia z bazą danych
        try {
          await prisma.$connect();
          console.log("Database connection successful");
        } catch (connectionError) {
          console.error("Database connection failed:", connectionError);
          throw new Error("Database connection failed");
        }
        
        subscription = await prisma.emailSubscription.create({
          data: {
            email: cleanEmail,
            acceptedTerms: zgodaPrzetwarzanie === true,
            acceptedContact: zgodaKontakt === true,
          },
        });
        console.log("Email subscription created:", subscription.id);
      } catch (dbError) {
        console.error("Database error (non-critical):", dbError);
        // Continue with offline mode - generate a temporary ID
        subscription = {
          id: `offline-${Date.now()}`,
          email: cleanEmail,
          acceptedTerms: zgodaPrzetwarzanie === true,
          acceptedContact: zgodaKontakt === true,
          createdAt: new Date(),
          isOfflineEntry: true
        };
        console.log("Using offline subscription:", subscription.id);
      } 
      
      // Create a new form submission with reference to the email subscription
      const formData = { ...sanitizedBody };

      // Usunięcie pól, które są zapisywane osobno
      delete formData.contactEmail;
      delete formData.zgodaPrzetwarzanie;
      delete formData.zgodaKontakt;
      delete formData.notHuman;
      delete formData.csrfToken;

      // Aktualizacja daty formularza dla spójności
      formData.submissionDate = new Date().toISOString(); 
      
      // Dodanie informacji o polach sądowych
      console.log("Zapisywane dane sądu:", {
        rokDecyzjiSad: formData.rokDecyzjiSad,
        miesiacDecyzjiSad: formData.miesiacDecyzjiSad,
        rodzajSaduSad: formData.rodzajSaduSad,
        apelacjaSad: formData.apelacjaSad || formData.apelacjaId,
        apelacjaId: formData.apelacjaId || formData.apelacjaSad,
        apelacjaNazwa: formData.apelacjaNazwa,
        sadOkregowyId: formData.sadOkregowyId,
        sadOkregowyNazwa: formData.sadOkregowyNazwa,
        sadRejonowyId: formData.sadRejonowyId,
        sadRejonowyNazwa: formData.sadRejonowyNazwa,
      }); 
      
      // Wyodrębnienie kluczowych pól do indeksowania
      const rodzajSaduSad = formData.rodzajSaduSad || null;
      const apelacjaSad = formData.apelacjaSad || formData.apelacjaId || null;
      const apelacjaId = formData.apelacjaId || formData.apelacjaSad || null;
      const apelacjaNazwa = formData.apelacjaNazwa || null;
      const sadOkregowyId = formData.sadOkregowyId || null;
      const sadOkregowyNazwa = formData.sadOkregowyNazwa || null;
      const sadRejonowyId = formData.sadRejonowyId || null;
      const sadRejonowyNazwa = formData.sadRejonowyNazwa || null;
      const rokDecyzjiSad = formData.rokDecyzjiSad || null;
      const watekWiny = formData.watekWiny || null;
      
      // Próba zapisania danych formularza do bazy
      let submission;
      let submissionId = `offline-${Date.now()}`; // Domyślne ID dla trybu offline
      
      try {
        console.log("Attempting to insert form submission...");
        
        // Sprawdza czy mamy do czynienia z wpisem offline
        if (subscription.isOfflineEntry) {
          console.log("Skipping database insert for offline entry");
          throw new Error("Offline entry - skipping database insert");
        }

        submission = (await prisma.$queryRaw`
          INSERT INTO "FormSubmission" (
            "id", 
            "emailSubscriptionId", 
            "formData", 
            "status",
            "rodzajSaduSad",
            "apelacjaSad",
            "apelacjaId",
            "apelacjaNazwa",
            "sadOkregowyId",
            "sadOkregowyNazwa",
            "sadRejonowyId",
            "sadRejonowyNazwa",
            "rokDecyzjiSad",
            "watekWiny"
          )
          VALUES (
            gen_random_uuid(), 
            ${subscription.id}, 
            ${JSON.stringify(formData)}::jsonb, 
            'pending',
            ${rodzajSaduSad},
            ${apelacjaSad},
            ${apelacjaId},
            ${apelacjaNazwa},
            ${sadOkregowyId},
            ${sadOkregowyNazwa},
            ${sadRejonowyId},
            ${sadRejonowyNazwa},
            ${rokDecyzjiSad},
            ${watekWiny}
          )
          RETURNING "id"
        `) as { id: string }[]; 
        
        // Jeśli zapis do bazy się powiódł, użyj ID z bazy danych
        submissionId = submission[0]?.id;
        console.log("Form submission created with ID:", submissionId);
        
        // Return success response with security headers
        return NextResponse.json(
          {
            success: true,
            message: "Formularz zapisany pomyślnie",
            id: submissionId,
          },
          {
            status: 201,
            headers: securityHeaders,
          }
        );
      } catch (dbError) {
        console.error("Database error:", dbError);

        // Check for duplicate email error
        if (
          dbError instanceof Error &&
          dbError.message.includes("Unique constraint failed")
        ) {
          return NextResponse.json(
            { error: "Ten adres email jest już zarejestrowany." },
            {
              status: 409,
              headers: securityHeaders,
            }
          );
        }

        // W przypadku błędu bazy danych, zwróć status offline z ID offline
        // Umożliwi to aplikacji klienta zapisanie danych lokalnie do późniejszej synchronizacji
        return NextResponse.json(
          {
            success: true,
            message: "Dane zapisane w trybie offline. Zostaną zsynchronizowane automatycznie.",
            id: submissionId,
            isOffline: true,
            sadRejonowyNazwa: formData.sadRejonowyNazwa || null,
            apelacjaNazwa: formData.apelacjaNazwa || null,
            sadOkregowyNazwa: formData.sadOkregowyNazwa || null
          },
          {
            status: 200, // Zwracamy 200 aby klient mógł obsłużyć tryb offline
            headers: securityHeaders,
          }
        );
      }
    } catch (error) {
      console.error("Error processing form submission:", error);
      // Nawet w przypadku całkowitego błędu, próbujemy umożliwić klientowi działanie offline
      const offlineId = `emergency-${Date.now()}`;
      return NextResponse.json(
        {
          success: true,
          message: "Zapisano w trybie awaryjnym. Prosimy o kontakt z obsługą.",
          id: offlineId,
          isOffline: true,
          isEmergency: true,
          error:
            "Wystąpił błąd podczas przetwarzania formularza. Spróbuj ponownie.",
        },
        {
          status: 500,
          headers: securityHeaders,
        }
      );
    }
  } catch (error) {
    console.error("Error processing form submission:", error);
    // Nawet w przypadku całkowitego błędu, próbujemy umożliwić klientowi działanie offline
    const offlineId = `emergency-${Date.now()}`;
    return NextResponse.json(
      {
        success: true,
        message: "Zapisano w trybie awaryjnym. Prosimy o kontakt z obsługą.",
        id: offlineId,
        isOffline: true,
        isEmergency: true,
        error:
          "Wystąpił błąd podczas przetwarzania formularza. Spróbuj ponownie.",
      },
      {
        status: 500,
        headers: securityHeaders,
      }
    );
  }
}
